import java.util.Arrays;

public class MaxHeap {
    private int[] heap;
    private int size;

    // Constructor to initialize the heap with a given capacity
    public MaxHeap(int capacity) {
        heap = new int[capacity];
        size = 0;
    }

    // Function to insert a new element into the heap
    public void insert(int value) {
        if (size >= heap.length) {
            throw new IndexOutOfBoundsException("Heap is full");
        }

        // Insert the value at the end of the heap
        heap[size] = value;
        size++;

        // Heapify up to maintain the max-heap property
        int i = size - 1;
        while (i > 0 && heap[(i - 1) / 2] < heap[i]) {
            // Swap the current node with its parent
            int temp = heap[i];
            heap[i] = heap[(i - 1) / 2];
            heap[(i - 1) / 2] = temp;

            // Move to the parent's index
            i = (i - 1) / 2;
        }
    }

    // Function to delete the root (max) element
    public int deleteRoot() {
        if (size == 0) {
            throw new IllegalStateException("Heap is empty");
        }

        // The root is the maximum element
        int root = heap[0];

        // Move the last element to the root
        heap[0] = heap[size - 1];
        size--;

        // Heapify down to restore the max-heap property
        heapify(0);

        return root;
    }

    // Helper function to restore the heap property (heapify)
    private void heapify(int i) {
        int largest = i; // Assume the largest is the root
        int left = 2 * i + 1; // Left child
        int right = 2 * i + 2; // Right child

        // Check if left child is larger than the root
        if (left < size && heap[left] > heap[largest]) {
            largest = left;
        }

        // Check if right child is larger than the largest so far
        if (right < size && heap[right] > heap[largest]) {
            largest = right;
        }

        // If the largest is not the root, swap and continue heapifying
        if (largest != i) {
            int temp = heap[i];
            heap[i] = heap[largest];
            heap[largest] = temp;

            // Recursively heapify the affected subtree
            heapify(largest);
        }
    }

    // Function to display the contents of the heap
    public void display() {
        System.out.println(Arrays.toString(Arrays.copyOf(heap, size)));
    }

    // Main function to test the MaxHeap class
    public static void main(String[] args) {
        MaxHeap maxHeap = new MaxHeap(10); // Create a MaxHeap with a capacity of 10

        // Inserting elements
        maxHeap.insert(10);
        maxHeap.insert(20);
        maxHeap.insert(30);
        maxHeap.insert(5);
        maxHeap.insert(15);

        // Display the heap after insertions
        System.out.println("Heap after insertions:");
        maxHeap.display();

        // Delete the root (max) element
        int deletedElement = maxHeap.deleteRoot();
        System.out.println("Deleted root element: " + deletedElement);

        // Display the heap after deletion
        System.out.println("Heap after deletion:");
        maxHeap.display();
    }
}

output:
Heap after insertions:
[30, 15, 20, 5, 10]
Deleted root element: 30
Heap after deletion:
[20, 15, 10, 5]

